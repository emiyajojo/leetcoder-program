# 使用什么遍历？
处理顺序和访问顺序！如果计算深度就需要使用后序遍历！

# 分治思想
一定要有左右的分治思想, 结合当前节点的操作+左右子树的操作

# 迭代遍历
## 中序
思路: 其实就是先一路遍历到最左端的左叶子,向最左遍历的过程中也将节点放进栈中,当向左遍历的过程中遇到空节点那么就是中节点遍历和右节点遍历的时候了
## 前序
一开始栈初始化的时候就塞根节点,以栈为空为循环终止条件,进行中左右顺序遍历,左和右遍历都是将节点放入栈中
## 后序
将前序遍历结果翻转即可

# 层序遍历
使用 **先进先出** 的队列结构, 使用队列非空为循环终止条件, 内层 `for` 循环使用队列当前长度为终止条件, 因此每次for循环开始前都需要额外记录deque.size, 同时`while` 循环之前, 需要将root塞入deque中

# 最大最小深度
最大深度很简单,直接使用边界判断+结尾返回1+max(左,右)即可,若用层序那就每个for循环结束后层数++就可
最小深度如果用层序,那么就需要注意, 在for循环一旦遍历到叶子节点就返回, 同时注意在进入for之前, 层数就要自增

# 所有路径
这题‘难’在不知道递归要不要返回值，其实这里如果要返回的话，很难知道什么时候将一条完整路径加入路径集合，并且如果使用返回值，那么使不使用额外变量记录路径？使用了额外变量，那么好像就不需要返回值了；
因此不返回值，而是使用传入迄今为止的当前路径记录，然后不返回值，这样方便
可以看看使用"路径总和"中的递归方法论

# 左叶子之和
只能用递归, 层序无法判断当前叶子是否在左边
使用递归, 深度遍历需要额外传入是否为左

# 树左下角的值
层次遍历, 每层更新一次最左边的值

# 路径总和&什么时候要返回值?
再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

## 路径总和II:
使用回溯,同时每次递归使用 1个差值作为函数传入值 & 全局变量记录当前路径,若该路径满足条件(当前节点是叶子节点), 则将该路径加入到另一个全局变量之中, 同时回溯的pop操作要在两个左右节点递归之后

# 从中序和后序遍历构造二叉树
思路: 由于每个节点值都不一样,可以通过值来确定节点
1. 首先, 通过后序遍历数组的最后一个节点值确定当前根节点
2. 在inroder找到该节点返回下标, inorder左区间是左子树,右区间是右子树
3. 通过indorder左区间和右区间, 确定postorder左区间右区间, 根据postorder性质,先左后右, 使用inorder遍历出来的左右区间长度直接在postorder切片就能得到postorder的左右子区间

# 构造最大二叉树
思路不难, 和之前中序后序构建二叉树一样, 使用下标记录当前子树的区间,而不是再构建一个新的数组来记录节点值

# 合并二叉树
不需要创多一个节点, 把树2节点值和树2新节点直接加到树1即可(反过来也一样)

# 验证二叉搜索树
使用一个全局变量记录当前最大值,然后使用中序遍历的顺序遍历搜索树, 看看是不是递增

# 二叉搜索树的最小绝对差
对于二叉搜索树的典型结构有错误的认识!
[236,104,701,null,227,null,911] 这是一棵有典型结构的二叉搜索树
本题思路是找左子树的最大值和右子树的最小值

还有更快的思路: 例如中序遍历的单调递增特性, 使用双指针记录当前和前一个节点值

# 二叉搜索树众数
题意理解很重要: 注意这里的众数为频率最高的节点值, 并且可能有多个最高频率的节点值

# 二叉树的最近公共祖先
思路: 当root为空, 或者当前节点为其中一个目标,则返回. 为什么当前节点为其中一个目标就返回? 不怕忽略掉其中一个目标是另一个目标的子孙吗? 其实这种情况会包含在上层节点的运算中
        
本题是得出左孩子以及中是否有p,q, 若两个孩子都有p或q那么证明当前节点即为答案, 若只有其中一个孩子有p或q则就证明孩子是答案

因此当前节点为其中一个目标就返回, 若是另一个目标在另一边,那么在递归返回的时候回到上层, 另一边的返回不为空. 若另一个目标就在这里, 那么另一边不为空, 并且趁早返回节省了向下递归的时间

# 二叉搜索树的最近公共祖先
思路: 从上到下遍历只要root在[p,q]中就是最近的公共祖先

# 删除二叉搜索树节点
思路: 这道题还是需要递归的
主要难点就在处理相等的情况,这里又有4种情况:
1. 左右空
2. 左空又不空
3. 右空左不空
4. 左右不空,这里需要找到右子树的最左叶子节点,把左子树接到右子树的最左叶子节点左边就可

# 裁剪二叉搜索树
就是将二叉搜索树往要求的区间靠:太小就要往右边靠,太大就要往左边靠
要不要返回值? 参照删除搜索树节点, 返回好点

# 数组构造二叉搜索树
递归区间取中间坐标, 使用(left+right)//2

# 搜索树转换成累加树
使用右中左遍历顺序, 只能用栈迭代了