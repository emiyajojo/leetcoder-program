# 回溯基础
## 解决什么问题?
- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

## 模板
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

# 组合问题
循环+递归, 别忘了终止
同时, 剪枝需要n-(k-len(path))+1+1, 第一个+1是:
1. 剩余需要选择的数字数量：need = k - len(path)
2. 当前数字位置：i
3. 从i到n之间最多有多少数字：n - i + 1
4. 剪枝条件：n - i + 1 >= need（剩余数字足够完成组合）
第二个+1是range遍历开区间导致要额外+1

# 组合总和III
和上面几乎一样,这里的n变成了目标和, 而原本的n也就是从哪里选变成了9, 这里要注意在递归迭代的时候注意start+1在循环中要写成i+1

# 分割回文串
这道题又有点不一样,这道题是要候选集的所有元素都算进去,也就是说,是分割而不是单纯地选
那么就有两个要点:
1. 不只是要用start, 还要用end, 结合递归和for循环刚好记录当前分割出来的子串
2. 对于剪枝,只在分割出来的子串满足回文才递归,同时,在for循环之前若是子串起始位置已经末尾,那么就直接返回
3. 同时要注意,path本质上是指不同的分割方式,因此也是需要记录的
# 复原IP
回忆一下回文串分割思路:
1. 边界条件判断
2. for循环:
    这里,是要以当前递归层传入的开始下标为头, 以当前for循环的循环下标为尾进行遍历
    那么深度? 假设当前for循环到了i, 那么就以i为尾取当前的子串进行判断,但是以i+1为头进行向下递归

本题基本一样,但是有个问题就是长度限制: IP地址最长的是4个3位数拼接, 比如255.255.255.255, 12位数字
若是当前的s长度>12,就可以返回,若是太短<4也可以返回
还有0开头的数字
同时要注意combine加入结果集的条件,只有满足了combine有4个元素并且此时已经遍历完整个候选s才将combine加入结果集

# 子集 I & II
子集I讲究一个百无禁忌,每次combine添加一个新元素的时候, res就可以添加一次combine的副本
子集II逻辑很简单,和子集I基本一样,但是要注意去重,去重逻辑和 40.组合总和II 一样

