# 回溯基础
## 解决什么问题?
- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

## 模板
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

# 组合问题
循环+递归, 别忘了终止
同时, 剪枝需要n-(k-len(path))+1+1, 第一个+1是:
1. 剩余需要选择的数字数量：need = k - len(path)
2. 当前数字位置：i
3. 从i到n之间最多有多少数字：n - i + 1
4. 剪枝条件：n - i + 1 >= need（剩余数字足够完成组合）
第二个+1是range遍历开区间导致要额外+1

# 组合总和III
和上面几乎一样,这里的n变成了目标和, 而原本的n也就是从哪里选变成了9, 这里要注意在递归迭代的时候注意start+1在循环中要写成i+1

# 分割回文串
这道题又有点不一样,这道题是要候选集的所有元素都算进去,也就是说,是分割而不是单纯地选
那么就有两个要点:
1. 不只是要用start, 还要用end, 结合递归和for循环刚好记录当前分割出来的子串
2. 对于剪枝,只在分割出来的子串满足回文才递归,同时,在for循环之前若是子串起始位置已经末尾,那么就直接返回
3. 同时要注意,path本质上是指不同的分割方式,因此也是需要记录的
# 复原IP
回忆一下回文串分割思路:
1. 边界条件判断
2. for循环:
    这里,是要以当前递归层传入的开始下标为头, 以当前for循环的循环下标为尾进行遍历
    那么深度? 假设当前for循环到了i, 那么就以i为尾取当前的子串进行判断,但是以i+1为头进行向下递归

本题基本一样,但是有个问题就是长度限制: IP地址最长的是4个3位数拼接, 比如255.255.255.255, 12位数字
若是当前的s长度>12,就可以返回,若是太短<4也可以返回
还有0开头的数字
同时要注意combine加入结果集的条件,只有满足了combine有4个元素并且此时已经遍历完整个候选s才将combine加入结果集

# 子集 I & II
子集I讲究一个百无禁忌,每次combine添加一个新元素的时候, res就可以添加一次combine的副本
子集II逻辑很简单,和子集I基本一样,但是要注意去重,去重逻辑和 40.组合总和II 一样

# 491. 非递减子序列
## 题目描述:

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

示例 1：

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

示例 2：

输入：nums = [4,4,3,2,1]
输出：[[4,4]]

## 思路:
去重逻辑不一样,因为数组不能排序
注意,去重是要在宽度也就是同层维度上,因此要在每个宽度循环外面初始化used
used下标值是nums值,元素是表示这个下标是否使用过
同时注意,子序列并不需要连起来

# 46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：

输入：nums = [1]
输出：[[1]]
## 思路
    思路:used的去重和递增子序列又不一样,这里used需要在深度的维度上去重
    同时,由于排列的每个元素的长度相同,也就是每个"组合"的元素多少相等,因此排列不需要开始下标,因为每次都要遍历整个数组

# 47. 全排列II
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]

示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

 

提示：

    1 <= nums.length <= 8
    -10 <= nums[i] <= 10

## 思路
used的去重和递增子序列又不一样,这里used需要在深度的维度上去重
同时,由于排列的每个元素的长度相同,也就是每个"组合"的元素多少相等,因此排列不需要开始下标,因为每次都要遍历整个数组
去重逻辑和组合总和II一样
used[i - 1] == true，说明同一树枝nums[i - 1]使用过
used[i - 1] == false，说明同一树层nums[i - 1]使用过

# 51. N 皇后
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
示例 1：
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
示例 2：
输入：n = 1
输出：[["Q"]]
提示：
1 <= n <= 9

## 思路
不能同行,不能同列,不能45度和135度(这两条**对角线**可以通过记录当前**行和列的和以及差**来记录)
检查只需要检查前面的,只需要**3个集合**就可以
棋盘需要初始化为完整的棋盘,不过是空白的
检查还需要传入坐标
结果集添加符合要求的棋盘副本直接使用