# 分饼干
# 53.最大子数组和
没有st的滑动窗口值维护最大和的滑动窗口

# 摆动序列
只需在prediff与curdiff符号相异的时候(也包括prediff为0的时候,把不等号加上一个等号)才更新prediff以及波峰数量

# 122.买卖股票的最佳时机 II
## 题目描述
力扣题目链接
(opens new window)
给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
    输入: [7,1,5,3,6,4]
    输出: 7
    解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:
    输入: [1,2,3,4,5]
    输出: 4
    解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例  3:
    输入: [7,6,4,3,1]
    输出: 0
    解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
提示：
    1 <= prices.length <= 3 * 10 ^ 4
    0 <= prices[i] <= 10 ^ 4
## 思路
把买卖的操作分割成每次时间步都为1的操作,只累加利润大于0的

# 55. 跳跃游戏
## 描述
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
提示：
    1 <= nums.length <= 104
    0 <= nums[i] <= 105

## 思路
更新一个最大可到达下标cover,而不是当前的元素能跳到哪里,并且还要注意当前下标是否能被cover覆盖到

# 45. 跳跃游戏 II
给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。
每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：
    0 <= j <= nums[i] 且
    i + j < n
返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。
示例 1:
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:
输入: nums = [2,3,0,1,4]
输出: 2
提示:
1 <= nums.length <= 104
0 <= nums[i] <= 1000
题目保证可以到达 n - 1
## 题解
思路:其实就是以遍历到列表倒数第二位为界,若当前下标遍历到当前最远边界,步数+1(若当前下标到了第二位但依然还没到达最远边界,就说明步数最远边界已经到达最后的下标甚至溢出)

同时使用**另一个next_cover**记录下一个最远可达边界, 在当前下标到达当前最远可达边界的时候,才更新当前最远可达边界,为了防止当前最远边界更新得太快,步数没更新

# 1005. K 次取反后最大化的数组和
给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
以这种方式修改数组后，返回数组 可能的最大和 。
示例 1：
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
示例 2：
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
示例 3：
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
提示：
    1 <= nums.length <= 104
    -100 <= nums[i] <= 100
    1 <= k <= 104
## 思路
从局部最优:优先将次数用在绝对值最大的负数上
到全局最优:剩下的次数用在绝对值最小的数上,无论是正负0
优化:应该先遍历整个排完序的列表,对于每个负数都尽可能地取反,若次数还有剩并且是非偶数,那就将绝对值最小的数取反


