# 四数相加
4个数组,元素为a,b,c,d 抽象表示
大体思路是:4个数组分成两个循环,前面先统计所有的a+b, 记录a+b的次数
后面两个数组, c+b==-(a+b),那么res+=count(a+b)

# 赎金信
类似于有效异位词
区别是，由于有效异位词是需要两个字符串的所有字符频数完全一样，因此使用1个数组先加后减，若是频数完全一样则所有元素都应该为0
本题就不一样，本题要求前一个字符串的所有元素的频数小于等于后一个字符串，因此两个数组，记录两组频数比较大小，或者一个数组先加后减，所有元素必须不小于0

# 三数之和

思路：3指针处理处理过的有序数组,i是当前元素,l,r双指针一小一大这里哈希不好做,因为要去重
3指针,有个问题是如何移动？其实就是要双重循环
边界条件、特殊条件判断：
1. nums[i-1]是重复的就要跳过，为什么是i-1？如果是i+1就跳过去那就漏了, 
2. nums[i]>0,此时不可能满足nums[i]+nums[l]+nums[r]==0,后面两个大于nums[i],3个正数之和>0

这里别忘了l也需要去重, nums[i]去重的逻辑对于l同样适用,对r不需要去重, 因为l从r左边过来,如果r去重那么可能会漏掉nums[l]==nums[r]的情况
对于lr去重还有另一个操作,就是先添加满足和为0的三元组,然后如果l右边的元素重复,或者r左边的元素重复,lr都要往中间缩

# 四数之和
思路和三数之和一样，不一样的是要加多一个遍历全数组的索引
i,j这两个索引，剪枝要考虑target小于0的情况，不能像3数之和那样nums[i]>target就break,因为即使nums[i]在4个索引指向的元素中最小(也就是说此时所有元素都大于target)，但是他右边的元素还是有可能小于0,加上右边之后依然有可能等于target,这个剪枝需要加上nums[i]>0的条件
i,j去重的话，外层i没啥说的，j去重的话左边界就是j+1
同时别忘了在lr去重的分支，记得lr无论去不去重指针都要动，不然的话就死循环了，同时，lr移动还有一个误区：去重的时候当退出了lr向内移动的while循环，lr刚好就在最后一个重复元素上，比如1，1，1，1，1，当退出while的时候l已经在最后一个1上了，再+=1就是下一个不和1重复的元素了